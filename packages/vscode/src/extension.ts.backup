/**
 * Aksara Writer VS Code Extension
 * Provides markdown conversion and preview capabilities
 */

import * as vscode from 'vscode';
import { exec } from 'child_process';
import { promisify } from 'util';
import { readFileSync, existsSync, readdirSync } from 'fs';
import { readFile } from 'fs/promises';
import { join, basename, extname, dirname } from 'path';
import * as path from 'path';

// Define types locally to avoid import issues
interface ConvertOptions {
    format: 'html' | 'pdf' | 'pptx';
    locale?: 'id' | 'en';
    theme?: string;
    pageSize?: 'A4' | 'Letter' | 'Legal';
    orientation?: 'portrait' | 'landscape';
}

const execAsync = promisify(exec);

// Global reference to the single preview panel
let globalPreviewPanel: vscode.WebviewPanel | undefined;
let previewSubscriptions: vscode.Disposable[] = [];
let syncSubscriptions: vscode.Disposable[] = [];

// Debouncing for live preview updates
let previewUpdateTimeout: NodeJS.Timeout | undefined;

// Editor-Preview Sync System
let syncEnabled = true;
let isUpdatingFromPreview = false;
let isUpdatingFromEditor = false;
let currentSyncedEditor: vscode.TextEditor | undefined;
let syncLockTimeout: NodeJS.Timeout | undefined;

// Sync helper functions
function setupEditorPreviewSync(editor: vscode.TextEditor, panel: vscode.WebviewPanel) {
    console.log('üîß Setting up editor-preview sync for:', editor.document.fileName);

    // Dispose existing sync subscriptions first
    syncSubscriptions.forEach(sub => sub.dispose());
    syncSubscriptions = [];

    // Store reference to currently synced editor
    currentSyncedEditor = editor;

    // Track cursor/scroll changes - only for the currently synced editor and when it has focus
    const cursorSubscription = vscode.window.onDidChangeTextEditorSelection(event => {
        if (event.textEditor === currentSyncedEditor &&
            !isUpdatingFromPreview &&
            !isUpdatingFromEditor &&
            syncEnabled &&
            event.textEditor === vscode.window.activeTextEditor) {

            // Set editor sync lock
            isUpdatingFromEditor = true;
            clearTimeout(syncLockTimeout);

            const line = event.selections[0].active.line;
            const section = getSectionFromLine(event.textEditor.document, line);

            console.log('üì§ Editor cursor change - sending to preview:', { line, section, file: event.textEditor.document.fileName });
            panel.webview.postMessage({
                type: 'cursor-moved',
                line: line,
                section: section,
                sourceFile: event.textEditor.document.fileName
            });

            // Release lock after short delay
            syncLockTimeout = setTimeout(() => {
                isUpdatingFromEditor = false;
                console.log('üîì Editor cursor sync lock released');
            }, 800);

        } else if (isUpdatingFromPreview || isUpdatingFromEditor) {
            console.log('üîí Skipping cursor sync - sync in progress');
        } else if (event.textEditor !== vscode.window.activeTextEditor) {
            console.log('üîí Skipping cursor sync - editor not focused');
        }
    });

    const scrollSubscription = vscode.window.onDidChangeTextEditorVisibleRanges(event => {
        if (event.textEditor === currentSyncedEditor &&
            !isUpdatingFromPreview &&
            !isUpdatingFromEditor &&
            syncEnabled &&
            event.textEditor === vscode.window.activeTextEditor) {

            // Set editor sync lock
            isUpdatingFromEditor = true;
            clearTimeout(syncLockTimeout);

            const topLine = event.visibleRanges[0]?.start.line || 0;
            const section = getSectionFromLine(event.textEditor.document, topLine);

            console.log('üì§ Editor scroll change - sending to preview:', { line: topLine, section, file: event.textEditor.document.fileName });
            panel.webview.postMessage({
                type: 'scroll-changed',
                line: topLine,
                section: section,
                sourceFile: event.textEditor.document.fileName
            });

            // Release lock after short delay
            syncLockTimeout = setTimeout(() => {
                isUpdatingFromEditor = false;
                console.log('üîì Editor scroll sync lock released');
            }, 800);

        } else if (isUpdatingFromPreview || isUpdatingFromEditor) {
            console.log('üîí Skipping scroll sync - sync in progress');
        }
    });

    // Handle messages from preview
    const messageSubscription = panel.webview.onDidReceiveMessage(message => {
        console.log('üì® Received message from preview:', message);
        if (!syncEnabled || !currentSyncedEditor || isUpdatingFromEditor) {
            console.log('üîí Skipping preview message - sync disabled, no editor, or editor sync in progress');
            return;
        }

        // Only process messages for the currently synced editor
        switch (message.type) {
            case 'preview-scroll':
                console.log('üîÑ Processing preview-scroll message:', { line: message.line, section: message.section });
                syncEditorToPreview(currentSyncedEditor, message.line, message.section);
                break;
            case 'slide-changed':
                console.log('üîÑ Processing slide-changed message:', { section: message.section });
                syncEditorToSlide(currentSyncedEditor, message.section);
                break;
            default:
                console.log('‚ùì Unknown message type from preview:', message.type);
                break;
        }
    });

    // Store sync subscriptions for cleanup
    syncSubscriptions.push(cursorSubscription, scrollSubscription, messageSubscription);

    // Clean up on panel dispose
    panel.onDidDispose(() => {
        syncSubscriptions.forEach(sub => sub.dispose());
        syncSubscriptions = [];
    });
}

function getSectionFromLine(document: vscode.TextDocument, line: number): number {
    let section = 0;
    const sections = [];

    // Check if this is a presentation (only horizontal rules define slides)
    const content = document.getText();
    const isPresentation = content.includes('type: presentation') || content.includes('type:presentation');

    for (let i = 0; i <= line; i++) {
        const lineText = document.lineAt(i).text.trim();

        // For presentations: only count horizontal rules as section boundaries
        // For documents: count both horizontal rules and H1 headers
        const isHorizontalRule = /^-{3,}$/.test(lineText);
        const isH1Header = lineText.startsWith('# ') && lineText.length > 2 && i > 0;
        const isAksaraSection = lineText.includes('<!-- section -->') || lineText.includes('data-section');

        let isSectionBoundary = false;
        let boundaryType = '';

        if (isHorizontalRule) {
            isSectionBoundary = true;
            boundaryType = 'HR';
        } else if (!isPresentation && isH1Header) {
            // Only count H1 headers in document mode, not presentation mode
            isSectionBoundary = true;
            boundaryType = 'H1';
        } else if (isAksaraSection) {
            isSectionBoundary = true;
            boundaryType = 'Aksara';
        }

        if (isSectionBoundary) {
            section++;
            sections.push(`Line ${i}: "${lineText}" (${boundaryType})`);
        }
    }
    console.log(`üîç Section detection for line ${line}: section=${section}, mode=${isPresentation ? 'presentation' : 'document'}, boundaries:`, sections);
    return section;
}

function getLineFromSection(document: vscode.TextDocument, targetSection: number): number {
    let section = 0;

    // Check if this is a presentation (same logic as getSectionFromLine)
    const content = document.getText();
    const isPresentation = content.includes('type: presentation') || content.includes('type:presentation');

    for (let i = 0; i < document.lineCount; i++) {
        const lineText = document.lineAt(i).text.trim();

        // Use same section boundary logic as getSectionFromLine
        const isHorizontalRule = /^-{3,}$/.test(lineText);
        const isH1Header = lineText.startsWith('# ') && lineText.length > 2 && i > 0;
        const isAksaraSection = lineText.includes('<!-- section -->') || lineText.includes('data-section');

        let isSectionBoundary = false;

        if (isHorizontalRule) {
            isSectionBoundary = true;
        } else if (!isPresentation && isH1Header) {
            // Only count H1 headers in document mode, not presentation mode
            isSectionBoundary = true;
        } else if (isAksaraSection) {
            isSectionBoundary = true;
        }

        if (isSectionBoundary) {
            section++;
        }
        if (section === targetSection) {
            return Math.min(i + 1, document.lineCount - 1); // Return line after separator, but within bounds
        }
    }
    return 0;
}

function syncEditorToPreview(editor: vscode.TextEditor, line: number, section: number) {
    if (isUpdatingFromEditor) {
        console.log('üîí Skipping editor sync - editor update in progress');
        return;
    }

    isUpdatingFromPreview = true;
    clearTimeout(syncLockTimeout);

    console.log('üîÑ Syncing editor to preview:', { line, section });

    const targetLine = line || getLineFromSection(editor.document, section);
    const position = new vscode.Position(targetLine, 0);
    const selection = new vscode.Selection(position, position);

    editor.selection = selection;
    editor.revealRange(new vscode.Range(position, position), vscode.TextEditorRevealType.AtTop);

    syncLockTimeout = setTimeout(() => {
        isUpdatingFromPreview = false;
        console.log('üîì Preview sync lock released');
    }, 1000); // Longer timeout to prevent sync loops
}

function syncEditorToSlide(editor: vscode.TextEditor, section: number) {
    const targetLine = getLineFromSection(editor.document, section);
    syncEditorToPreview(editor, targetLine, section);
}

/**
 * Fix image paths in HTML for VS Code webview
 */
function fixImagePathsInHtml(html: string, documentPath: string, webview: vscode.Webview): string {
    const docDir = path.dirname(documentPath);

    // First fix CSS background images
    html = html.replace(/(background-image:\s*url\(['"]?)([^'")]+)(['"]?\))/g, (match, prefix, src, suffix) => {
        // Skip if already a data URL, HTTP URL, or webview resource
        if (src.startsWith('data:') || src.startsWith('http') || src.startsWith('vscode-webview-resource:')) {
            return match;
        }

        console.log('üñºÔ∏è Fixing CSS background image path:', src);

        // Convert relative paths to absolute paths, then to webview URIs
        let absolutePath: string;
        if (src.startsWith('./')) {
            absolutePath = path.join(docDir, src.substring(2));
        } else if (src.startsWith('../')) {
            absolutePath = path.resolve(docDir, src);
        } else if (!path.isAbsolute(src)) {
            absolutePath = path.join(docDir, src);
        } else {
            absolutePath = src;
        }

        // Convert to webview URI
        try {
            const webviewUri = webview.asWebviewUri(vscode.Uri.file(absolutePath));
            console.log('‚úÖ Fixed CSS background path:', src, '->', webviewUri.toString());
            return `${prefix}${webviewUri.toString()}${suffix}`;
        } catch (error) {
            console.warn(`Failed to convert CSS background path: ${src}`, error);
            return match;
        }
    });

    // Then fix image src attributes with webview URIs
    return html.replace(/(<img[^>]+src=["'])([^"']+)(["'][^>]*>)/g, (match, prefix, src, suffix) => {
        // Skip if already a data URL, HTTP URL, or webview resource
        if (src.startsWith('data:') || src.startsWith('http') || src.startsWith('vscode-webview-resource:')) {
            return match;
        }

        console.log('üñºÔ∏è Fixing img src path:', src);

        // Convert relative paths to absolute paths, then to webview URIs
        let absolutePath: string;
        if (src.startsWith('./')) {
            absolutePath = path.join(docDir, src.substring(2));
        } else if (src.startsWith('../')) {
            absolutePath = path.resolve(docDir, src);
        } else if (!path.isAbsolute(src)) {
            absolutePath = path.join(docDir, src);
        } else {
            absolutePath = src;
        }

        // Convert to webview URI
        try {
            const webviewUri = webview.asWebviewUri(vscode.Uri.file(absolutePath));
            console.log('‚úÖ Fixed img src path:', src, '->', webviewUri.toString());
            return `${prefix}${webviewUri.toString()}${suffix}`;
        } catch (error) {
            console.warn(`Failed to convert image path: ${src}`, error);
            return match;
        }
    });
}

/**
 * Generate HTML for non-Aksara documents
 */
function getNoAksaraHtml(fileName: string): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aksara Writer - No Directive</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 2rem;
            background: #f8f9fa;
            color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            text-align: center;
        }
        .icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }
        h1 {
            color: #34495e;
            margin-bottom: 1rem;
        }
        .filename {
            background: #ecf0f1;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-family: monospace;
            margin: 1rem 0;
            color: #2c3e50;
        }
        .instructions {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            text-align: left;
        }
        .instructions h3 {
            margin-top: 0;
            color: #0c5460;
        }
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1rem;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            margin: 1rem 0;
            text-align: left;
        }
        .note {
            color: #6c757d;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">üìÑ</div>
        <h1>Aksara Writer Preview</h1>
        <div class="filename">${fileName}</div>

        <div class="instructions">
            <h3>üîß To enable Aksara Writer preview:</h3>
            <p>Add the following directive to the top of your markdown file:</p>
            <pre class="code-block">&lt;!--
aksara:true
type: document
--&gt;

# Your Content Here</pre>
            <p><strong>For presentations:</strong></p>
            <pre class="code-block">&lt;!--
aksara:true
type: presentation
size: 16:9
--&gt;

# Your Presentation</pre>
        </div>

        <div class="note">
            This file will automatically preview when you add the <code>aksara:true</code> directive.
        </div>
    </div>
</body>
</html>
    `;
}

interface ConvertOptions {
    format: 'html' | 'pdf' | 'pptx';
    locale?: 'id' | 'en';
    theme?: string;
    pageSize?: 'A4' | 'Letter' | 'Legal';
}

/**
 * Convert markdown to HTML using CLI via stdin/stdout (live preview)
 */
async function convertToHtmlInMemory(markdown: string, documentPath?: string): Promise<string> {
    try {
        // Use CLI with stdin/stdout for live preview (no file I/O)
        // Set working directory to document directory for proper path resolution
        const workingDir = documentPath ? path.dirname(documentPath) : process.cwd();
        const config = vscode.workspace.getConfiguration('aksara');
        const theme = config.get<string>('defaultTheme', 'default');
        const locale = config.get<'id' | 'en'>('defaultLocale', 'id');
        const command = `aksara-writer convert - --format html --stdout --locale ${locale} --theme ${theme}`;

        const { spawn } = await import('child_process');

        return new Promise((resolve, reject) => {
            const child = spawn('bash', ['-c', command], {
                stdio: ['pipe', 'pipe', 'pipe'],
                cwd: workingDir // Set working directory to document directory
            });

            let stdout = '';
            let stderr = '';

            child.stdout.on('data', (data) => {
                stdout += data.toString();
            });

            child.stderr.on('data', (data) => {
                stderr += data.toString();
            });

            child.on('close', (code) => {
                if (code === 0) {
                    resolve(stdout);
                } else {
                    console.warn('CLI conversion failed:', stderr);
                    reject(new Error(`CLI failed with code ${code}: ${stderr}`));
                }
            });

            child.on('error', (error) => {
                console.warn('CLI spawn error:', error);
                reject(error);
            });

            // Send markdown to CLI via stdin
            child.stdin.write(markdown);
            child.stdin.end();
        });
    } catch (error) {
        console.warn('CLI converter failed, falling back to simple converter:', error);
        return convertToHtmlSimple(markdown);
    }
}

/**
 * Fallback simple converter (backup when core fails)
 */
function convertToHtmlSimple(markdown: string): string {
    // Basic markdown to HTML conversion for preview
    let html = markdown;

    // Process JavaScript expressions first
    html = html.replace(/\$\{([^}]+)\}/g, (match, expression) => {
        try {
            if (expression.includes('new Date()')) {
                if (expression.includes('.toLocaleDateString(')) {
                    const localeMatch = expression.match(/\.toLocaleDateString\(['"](.*?)['"]\)/);
                    const locale = localeMatch ? localeMatch[1] : 'id-ID';
                    return new Date().toLocaleDateString(locale);
                }
                if (expression.includes('.getFullYear()')) {
                    return new Date().getFullYear().toString();
                }
            }
            if (expression.includes('Date.now()')) {
                const offsetMatch = expression.match(/Date\.now\(\)\s*([+\-])\s*(.+?)\)\.toLocaleDateString/);
                if (offsetMatch) {
                    const operator = offsetMatch[1];
                    const offsetMs = eval(offsetMatch[2]); // Safe for simple math
                    const dateMs = operator === '+' ? Date.now() + offsetMs : Date.now() - offsetMs;
                    return new Date(dateMs).toLocaleDateString('id-ID');
                }
            }
            return match;
        } catch {
            return match;
        }
    });

    // Remove Aksara directives
    html = html.replace(/<!--[\s\S]*?-->/g, '');

    // Convert markdown to HTML
    html = html
        // Headers
        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
        .replace(/^#### (.*$)/gm, '<h4>$1</h4>')

        // Bold and italic
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')

        // Code
        .replace(/`(.*?)`/g, '<code>$1</code>')

        // Lists
        .replace(/^- (.*$)/gm, '<li>$1</li>')
        .replace(/^(\d+)\. (.*$)/gm, '<li>$2</li>')

        // Images
        .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto;">')

        // Links
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')

        // Horizontal rules
        .replace(/^---$/gm, '<hr>');

    // Process tables
    html = html.replace(/^\|(.+)\|\s*\n\|[-\s|:]+\|\s*\n((?:\|.+\|\s*\n?)*)/gm, (match, headerRow, bodyRows) => {
        const headers = headerRow.split('|').map((h: string) => h.trim()).filter((h: string) => h);
        const rows = bodyRows.trim().split('\n').map((row: string) =>
            row.split('|').map((cell: string) => cell.trim()).filter((cell: string) => cell)
        );

        const headerHtml = headers.map((h: string) => `<th>${h}</th>`).join('');
        const bodyHtml = rows.map((row: string[]) =>
            `<tr>${row.map((cell: string) => `<td>${cell}</td>`).join('')}</tr>`
        ).join('');

        return `<table style="border-collapse: collapse; width: 100%;"><thead><tr>${headerHtml}</tr></thead><tbody>${bodyHtml}</tbody></table>`;
    });

    // Wrap list items in ul tags
    html = html.replace(/(<li>.*?<\/li>\s*)+/g, (match) => {
        return `<ul>${match}</ul>`;
    });

    // Convert line breaks to paragraphs
    const lines = html.split('\n');
    const processedLines: string[] = [];

    for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed === '') continue;

        // Don't wrap block elements
        if (trimmed.match(/^<(h[1-6]|ul|ol|li|table|div|hr|img)/)) {
            processedLines.push(trimmed);
        } else if (trimmed.match(/^<\/?(h[1-6]|ul|ol|li|table|div|hr)/)) {
            processedLines.push(trimmed);
        } else {
            processedLines.push(`<p>${trimmed}</p>`);
        }
    }

    // Add basic CSS
    const styledHtml = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ak'sara Preview</title>
    <style>
        body {
            font-family: 'Inter', 'Segoe UI', 'Noto Sans', sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            max-width: 21cm;
            margin: 0 auto;
            padding: 2rem;
            background: white;
        }
        h1 { color: #2c3e50; border-bottom: 3px solid #667eea; padding-bottom: 0.5rem; }
        h2, h3, h4 { color: #34495e; }
        table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
        th, td { border: 1px solid #bdc3c7; padding: 0.75rem; text-align: left; }
        th { background: #34495e; color: white; font-weight: 600; }
        tr:nth-child(even) { background: #f8f9fa; }
        code { background: #ecf0f1; padding: 0.2rem 0.4rem; border-radius: 3px; }
        ul { padding-left: 1.5rem; }
        li { margin: 0.5rem 0; }
        hr { border: none; border-top: 2px solid #ecf0f1; margin: 2rem 0; }
    </style>
</head>
<body>
    ${processedLines.join('\n')}
</body>
</html>`;

    return styledHtml;
}

/**
 * Convert document using Aksara CLI (for file exports) - original approach
 */
async function convertWithCli(filePath: string, options: ConvertOptions): Promise<{success: boolean, data?: string, error?: string}> {
    try {
        // Use global aksara-writer CLI (file-based conversion)
        const command = `aksara-writer convert "${filePath}" --format ${options.format} --locale ${options.locale || 'id'}`;

        const { stdout, stderr } = await execAsync(command, { cwd: path.dirname(filePath) });

        // Check if conversion was successful by looking for success message or absence of real errors
        if (stderr && stderr.includes('Error:') && !stdout.includes('Document converted successfully')) {
            return { success: false, error: stderr };
        }

        // For HTML format, read the output file
        if (options.format === 'html') {
            const outputPath = filePath.replace(/\.md$/, '.html');
            try {
                const htmlContent = await readFile(outputPath, 'utf-8');
                return { success: true, data: htmlContent };
            } catch (readError) {
                return { success: false, error: `Could not read HTML output: ${readError}` };
            }
        }

        return { success: true, data: stdout };
    } catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
        };
    }
}

export function activate(context: vscode.ExtensionContext) {
    console.log('Aksara Writer extension is now active!');

    // Register main menu command
    const command = vscode.commands.registerCommand('aksara.showMenu', showAksaraMenu);
    context.subscriptions.push(command);

    // Register smart preview command for context menu
    const previewCommand = vscode.commands.registerCommand('aksara.openPreview', openSmartPreview);
    context.subscriptions.push(previewCommand);

    // Show welcome message
    vscode.window.showInformationMessage(
        'Aksara Writer is ready! üöÄ',
        'View Templates',
        'Documentation'
    ).then(selection => {
        if (selection === 'View Templates') {
            insertTemplate();
        } else if (selection === 'Documentation') {
            vscode.env.openExternal(vscode.Uri.parse('https://ak-sara.github.io'));
        }
    });
}

/**
 * Show Aksara Writer menu (like Marp)
 */
async function showAksaraMenu() {
    const menuItems = [
        { label: 'üëÅÔ∏è Preview Document', description: 'Open live preview', action: 'preview' },
        { label: 'üìÑ Export to PDF', description: 'Generate PDF document', action: 'pdf' },
        { label: 'üìä Export to PowerPoint', description: 'Generate PPTX presentation', action: 'pptx' },
        { label: 'üåê Export to HTML', description: 'Generate HTML document', action: 'html' },
        { label: 'üìù Insert Template', description: 'Add business template', action: 'template' },
        { label: 'üé® Change Theme', description: 'Select document theme', action: 'theme' }
    ];

    const selected = await vscode.window.showQuickPick(menuItems, {
        placeHolder: 'Choose an action for your Aksara document'
    });

    if (!selected) return;

    switch (selected.action) {
        case 'preview':
            await previewDocument();
            break;
        case 'pdf':
            await exportDocument('pdf');
            break;
        case 'pptx':
            await exportDocument('pptx');
            break;
        case 'html':
            await exportDocument('html');
            break;
        case 'template':
            await insertTemplate();
            break;
        case 'theme':
            await changeTheme();
            break;
    }
}

/**
 * Smart preview function that detects Aksara directives and chooses appropriate preview
 */
async function openSmartPreview() {
    const editor = vscode.window.activeTextEditor;
    if (!editor || editor.document.languageId !== 'markdown') {
        vscode.window.showErrorMessage('Please open a markdown file first');
        return;
    }

    try {
        const document = editor.document;
        const markdown = document.getText();

        // Check if document has Aksara directives
        const hasAksaraDirective = markdown.includes('aksara:true') || markdown.includes('data-aksara');

        if (hasAksaraDirective) {
            console.log('üìÑ Aksara directive detected - opening Ak\'sara preview');
            vscode.window.showInformationMessage('Opening Ak\'sara preview...', { modal: false });
            await previewDocument();
        } else {
            console.log('üìÑ No Aksara directive - opening default VS Code preview');
            vscode.window.showInformationMessage('No Aksara directive found - opening default preview...', { modal: false });
            // Open default VS Code markdown preview
            await vscode.commands.executeCommand('markdown.showPreview');
        }

    } catch (error) {
        console.error('Error in smart preview:', error);
        vscode.window.showErrorMessage(`Preview error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}

/**
 * Preview current markdown document
 */
async function previewDocument(context?: vscode.ExtensionContext) {
    const editor = vscode.window.activeTextEditor;
    if (!editor || editor.document.languageId !== 'markdown') {
        vscode.window.showErrorMessage('Please open a markdown file first');
        return;
    }

    try {
        const document = editor.document;
        const markdown = document.getText();

        const config = vscode.workspace.getConfiguration('aksara');
        const options: ConvertOptions = {
            format: 'html',
            locale: config.get<'id' | 'en'>('defaultLocale', 'id'),
            theme: config.get<string>('defaultTheme', 'default'),
            pageSize: config.get<'A4' | 'Letter' | 'Legal'>('defaultPageSize', 'A4')
        };

        // Use core-based in-memory conversion for WYSIWYG preview
        const htmlContent = await convertToHtmlInMemory(markdown, document.fileName);
        const result = { success: true, data: htmlContent };

        if (!result.success) {
            vscode.window.showErrorMessage(`Failed to create preview: Unknown error`);
            return;
        }

        // Create or reuse panel
        if (!globalPreviewPanel) {
            // Create new panel
            globalPreviewPanel = vscode.window.createWebviewPanel(
                'aksaraPreview',
                `Ak'sara: ${path.basename(document.fileName)}`,
                vscode.ViewColumn.Two,
                {
                    enableScripts: true,
                    retainContextWhenHidden: true,
                    localResourceRoots: context ? [
                        vscode.Uri.file(path.dirname(document.fileName)),
                        vscode.Uri.file(path.join(context.extensionPath, 'dist'))
                    ] : [vscode.Uri.file(path.dirname(document.fileName))]
                }
            );

            // Setup editor-preview sync
            setupEditorPreviewSync(editor, globalPreviewPanel);

            // Update the title to include sync indicator
            globalPreviewPanel.title = `Ak'sara: ${path.basename(document.fileName)} üîó`;

            // Try to move panel to bottom automatically
            setTimeout(async () => {
                try {
                    await vscode.commands.executeCommand('workbench.action.moveEditorToBelowGroup');
                } catch (error) {
                    console.log('Could not automatically move preview to bottom:', error);
                }
            }, 100);

            // Clear reference when panel is disposed
            globalPreviewPanel.onDidDispose(() => {
                globalPreviewPanel = undefined;
            });
        }

        // Fix image paths for VS Code webview (but preserve base64 data URLs)
        let processedHtml = fixImagePathsInHtml(result.data!.toString(), document.fileName, globalPreviewPanel.webview);

        // Add Content Security Policy to allow data URLs for images
        if (!processedHtml.includes('content-security-policy')) {
            processedHtml = processedHtml.replace(
                '<head>',
                `<head>
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src 'self' data: vscode-webview-resource: https:; script-src 'unsafe-inline'; style-src 'unsafe-inline';">`
            );
        }

        // Debug: Log if we have base64 images
        if (processedHtml.includes('data:image/')) {
            console.log('VS Code: Found base64 images in HTML');
        }

        // Inject document path information for additional JS processing
        const docUri = globalPreviewPanel.webview.asWebviewUri(vscode.Uri.file(document.fileName));
        const docDir = globalPreviewPanel.webview.asWebviewUri(vscode.Uri.file(path.dirname(document.fileName)));

        // Inject sync JavaScript
        const htmlWithSyncScript = injectSyncScript(processedHtml, document.fileName, globalPreviewPanel.webview);

        // Update panel content
        globalPreviewPanel.title = `Ak'sara: ${path.basename(document.fileName)}`;
        globalPreviewPanel.webview.html = htmlWithSyncScript;
        globalPreviewPanel.reveal(vscode.ViewColumn.Two, true);

        // Try to move panel to bottom if it's not already there
        setTimeout(async () => {
            try {
                await vscode.commands.executeCommand('workbench.action.moveEditorToBelowGroup');
            } catch (error) {
                console.log('Could not automatically move preview to bottom on reveal:', error);
            }
        }, 100);

        // Set up subscriptions only once when creating the panel
        if (previewSubscriptions.length === 0) {
            // Update preview when active document changes
            const activeEditorChangeSubscription = vscode.window.onDidChangeActiveTextEditor(async activeEditor => {
                if (activeEditor && activeEditor.document.languageId === 'markdown' && globalPreviewPanel) {
                    // Clear any ongoing sync operations
                    isUpdatingFromPreview = false;
                    isUpdatingFromEditor = false;
                    clearTimeout(syncLockTimeout);

                    // Update the synced editor reference when switching tabs
                    currentSyncedEditor = activeEditor;
                    console.log('üîÑ Synced editor updated to:', activeEditor.document.fileName);

                    // Re-setup sync for the new editor
                    setupEditorPreviewSync(activeEditor, globalPreviewPanel);

                    const markdown = activeEditor.document.getText();
                    if (markdown.includes('aksara:true') || markdown.includes('data-aksara')) {
                        // Use core-based in-memory conversion
                        const htmlContent = await convertToHtmlInMemory(markdown, activeEditor.document.fileName);

                        // Fix image paths and inject document path information
                        let processedHtml = fixImagePathsInHtml(htmlContent, activeEditor.document.fileName, globalPreviewPanel.webview);

                        // Add Content Security Policy to allow data URLs for images
                        if (!processedHtml.includes('content-security-policy')) {
                            processedHtml = processedHtml.replace(
                                '<head>',
                                `<head>
                                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src 'self' data: vscode-webview-resource: https:; script-src 'unsafe-inline'; style-src 'unsafe-inline';">`
                            );
                        }

                        const docUri = globalPreviewPanel.webview.asWebviewUri(vscode.Uri.file(activeEditor.document.fileName));
                        const docDir = globalPreviewPanel.webview.asWebviewUri(vscode.Uri.file(path.dirname(activeEditor.document.fileName)));

                        const htmlWithSync = injectSyncScript(processedHtml, activeEditor.document.fileName, globalPreviewPanel.webview);

                        globalPreviewPanel.title = `Ak'sara: ${path.basename(activeEditor.document.fileName)}`;
                        globalPreviewPanel.webview.html = htmlWithSync;
                    } else {
                        // Show message for non-Aksara documents instead of closing
                        globalPreviewPanel.title = `Ak'sara: ${path.basename(activeEditor.document.fileName)} (No Aksara)`;
                        globalPreviewPanel.webview.html = getNoAksaraHtml(path.basename(activeEditor.document.fileName));
                    }
                }
            });

            // Update preview when document changes (with debouncing)
            const changeSubscription = vscode.workspace.onDidChangeTextDocument(async event => {
                if (event.document.languageId === 'markdown' && globalPreviewPanel) {
                    const activeEditor = vscode.window.activeTextEditor;
                    if (activeEditor && event.document === activeEditor.document) {
                        // Clear previous timeout
                        if (previewUpdateTimeout) {
                            clearTimeout(previewUpdateTimeout);
                        }

                        // Debounce updates to avoid too many renders
                        previewUpdateTimeout = setTimeout(async () => {
                            const markdown = event.document.getText();
                            if (markdown.includes('aksara:true') || markdown.includes('data-aksara')) {
                                // Use core-based in-memory conversion
                                const htmlContent = await convertToHtmlInMemory(markdown, event.document.fileName);

                                // Fix image paths and inject document path information
                                let processedHtml = fixImagePathsInHtml(htmlContent, event.document.fileName, globalPreviewPanel!.webview);

                                // Add Content Security Policy to allow data URLs for images
                                if (!processedHtml.includes('content-security-policy')) {
                                    processedHtml = processedHtml.replace(
                                        '<head>',
                                        `<head>
                                        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src 'self' data: vscode-webview-resource: https:; script-src 'unsafe-inline'; style-src 'unsafe-inline';">`
                                    );
                                }

                                const docUri = globalPreviewPanel!.webview.asWebviewUri(vscode.Uri.file(event.document.fileName));
                                const docDir = globalPreviewPanel!.webview.asWebviewUri(vscode.Uri.file(path.dirname(event.document.fileName)));

                                const htmlWithSync = injectSyncScript(processedHtml, event.document.fileName, globalPreviewPanel!.webview);

                                globalPreviewPanel!.title = `Ak'sara: ${path.basename(event.document.fileName)}`;
                                globalPreviewPanel!.webview.html = htmlWithSync;
                            } else {
                                // Show message if Aksara directive is removed instead of closing
                                globalPreviewPanel!.title = `Ak'sara: ${path.basename(event.document.fileName)} (No Aksara)`;
                                globalPreviewPanel!.webview.html = getNoAksaraHtml(path.basename(event.document.fileName));
                            }
                        }, 300); // 300ms debounce
                    }
                }
            });

            previewSubscriptions.push(activeEditorChangeSubscription, changeSubscription);

            // Clear reference and dispose subscriptions when panel is disposed
            globalPreviewPanel.onDidDispose(() => {
                previewSubscriptions.forEach(sub => sub.dispose());
                previewSubscriptions = [];
                globalPreviewPanel = undefined;
            });
        }

    } catch (error) {
        vscode.window.showErrorMessage(`Error preview: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}

/**
 * Export document to specified format
 */
async function exportDocument(format: 'pdf' | 'pptx' | 'html') {
    const editor = vscode.window.activeTextEditor;
    if (!editor || editor.document.languageId !== 'markdown') {
        vscode.window.showErrorMessage('Please open a markdown file first');
        return;
    }

    try {
        // Save document if dirty
        if (editor.document.isDirty) {
            await editor.document.save();
        }

        const document = editor.document;
        const markdown = document.getText();

        const config = vscode.workspace.getConfiguration('aksara');
        const options: ConvertOptions = {
            format,
            locale: config.get<'id' | 'en'>('defaultLocale', 'id'),
            theme: config.get<string>('defaultTheme', 'default'),
            pageSize: config.get<'A4' | 'Letter' | 'Legal'>('defaultPageSize', 'A4')
        };

        // Show progress
        const progress = await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: `Exporting to ${format.toUpperCase()}...`,
            cancellable: false
        }, async (progress) => {
            progress.report({ increment: 0, message: 'Processing document...' });

            // Save document first
            await document.save();

            // Use CLI to convert (file-based export)
            const result = await convertWithCli(document.fileName, options);

            if (!result.success) {
                throw new Error(result.error);
            }

            progress.report({ increment: 50, message: 'Menyimpan file...' });

            // Get output path
            const inputPath = document.fileName;
            const ext = format === 'pptx' ? '.pptx' : format === 'pdf' ? '.pdf' : '.html';
            const outputPath = inputPath.replace(/\.md$/, ext);

            progress.report({ increment: 100, message: 'Complete!' });

            return outputPath;
        });

        vscode.window.showInformationMessage(
            `Document exported to ${format.toUpperCase()} successfully`,
            'Open File'
        ).then(selection => {
            if (selection === 'Open File') {
                vscode.env.openExternal(vscode.Uri.file(progress));
            }
        });

    } catch (error) {
        vscode.window.showErrorMessage(`Export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}

/**
 * Insert template into current document
 */
async function insertTemplate() {
    const templates = getAvailableTemplates();

    if (templates.length === 0) {
        vscode.window.showErrorMessage('No templates found');
        return;
    }

    const templateOptions = templates.map(template => ({
        label: `${template.icon} ${template.title}`,
        value: template.name
    }));

    const selected = await vscode.window.showQuickPick(templateOptions, {
        placeHolder: 'Select document template'
    });

    if (!selected) return;

    const templateContent = getTemplateContent(selected.value);

    // Always create new file for templates (better UX)
    const doc = await vscode.workspace.openTextDocument({
        language: 'markdown',
        content: templateContent
    });

    const editor = await vscode.window.showTextDocument(doc);

    // Auto-open preview if the template has Aksara directives
    if (templateContent.includes('aksara:true')) {
        // Small delay to ensure the document is fully loaded
        setTimeout(async () => {
            await previewDocument();
        }, 500);
    }
}

/**
 * Change document theme
 */
async function changeTheme() {
    const themes = [
        { label: 'üè¢ Default - Indonesian Business', value: 'default' },
        { label: '‚ú® Minimal - Clean Design', value: 'minimal' },
        { label: 'üèõÔ∏è Corporate - Formal Corporate', value: 'corporate' },
        { label: 'üèõÔ∏è Government - Government Official', value: 'government' }
    ];

    const selected = await vscode.window.showQuickPick(themes, {
        placeHolder: 'Select document theme'
    });

    if (!selected) return;

    const config = vscode.workspace.getConfiguration('aksara');
    await config.update('defaultTheme', selected.value, vscode.ConfigurationTarget.Global);

    vscode.window.showInformationMessage(`Theme changed to: ${selected.label}`);

    // Refresh preview if it's open
    if (globalPreviewPanel) {
        const editor = vscode.window.activeTextEditor;
        if (editor && editor.document.languageId === 'markdown') {
            const markdown = editor.document.getText();
            if (markdown.includes('aksara:true') || markdown.includes('data-aksara')) {
                const htmlContent = await convertToHtmlInMemory(markdown, editor.document.fileName);
                let processedHtml = fixImagePathsInHtml(htmlContent, editor.document.fileName, globalPreviewPanel.webview);

                if (!processedHtml.includes('content-security-policy')) {
                    processedHtml = processedHtml.replace(
                        '<head>',
                        `<head>
                        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src 'self' data: vscode-webview-resource: https:; script-src 'unsafe-inline'; style-src 'unsafe-inline';">`
                    );
                }

                const docUri = globalPreviewPanel.webview.asWebviewUri(vscode.Uri.file(editor.document.fileName));
                const docDir = globalPreviewPanel.webview.asWebviewUri(vscode.Uri.file(path.dirname(editor.document.fileName)));

                const htmlWithSync = injectSyncScript(processedHtml, editor.document.fileName, globalPreviewPanel.webview);

                globalPreviewPanel.webview.html = htmlWithSync;
            }
        }
    }
}

/**
 * Get available templates from the templates directory
 */
function getAvailableTemplates(): Array<{name: string, title: string, icon: string}> {
    try {
        const extensionPath = vscode.extensions.getExtension('ak-sara.aksara-writer-vscode')?.extensionPath;
        if (!extensionPath) {
            return [];
        }

        const templatesDir = join(extensionPath, 'templates');
        if (!existsSync(templatesDir)) {
            return [];
        }

        const templateFiles = readdirSync(templatesDir)
            .filter(file => extname(file) === '.md')
            .map(file => basename(file, '.md'));

        const templateMetadata: Record<string, {title: string, icon: string}> = {
            'default': { title: 'Default - General Document', icon: 'üìÑ' },
            'invoice': { title: 'Invoice - Sales Invoice', icon: 'üßæ' },
            'proposal': { title: 'Proposal - Business Proposal', icon: 'üìã' },
            'report': { title: 'Report - Business Report', icon: 'üìä' },
            'contract': { title: 'Contract - Legal Contract', icon: 'üìù' },
            'letter': { title: 'Letter - Official Letter', icon: 'üìÆ' }
        };

        return templateFiles.map(name => ({
            name,
            title: templateMetadata[name]?.title || `${name.charAt(0).toUpperCase() + name.slice(1)} Template`,
            icon: templateMetadata[name]?.icon || 'üìÑ'
        }));
    } catch (error) {
        console.error('Error reading templates:', error);
        return [];
    }
}

/**
 * Get template content from file
 */
function getTemplateContent(templateName: string): string {
    try {
        const extensionPath = vscode.extensions.getExtension('ak-sara.aksara-writer-vscode')?.extensionPath;
        if (!extensionPath) {
            return getFallbackTemplate();
        }

        const templatePath = join(extensionPath, 'templates', `${templateName}.md`);
        if (!existsSync(templatePath)) {
            return getFallbackTemplate();
        }

        return readFileSync(templatePath, 'utf-8');
    } catch (error) {
        console.error(`Error reading template ${templateName}:`, error);
        return getFallbackTemplate();
    }
}

/**
 * Inject VS Code sync script into HTML
 */
function injectSyncScript(html: string, documentFileName: string, webview: vscode.Webview): string {
    const docUri = webview.asWebviewUri(vscode.Uri.file(documentFileName));
    const docDir = webview.asWebviewUri(vscode.Uri.file(path.dirname(documentFileName)));

    // Get sync script from external file
    const syncScriptPath = path.join(__dirname, '..', 'lib', 'sync.js');
    let syncScript = '';

    try {
        syncScript = readFileSync(syncScriptPath, 'utf-8');
    } catch (error) {
        console.error('Failed to load sync script:', error);
        // Fallback to basic functionality
        syncScript = `
            console.log('‚ö†Ô∏è External sync script not found, using fallback');
            const vscode = acquireVsCodeApi();
        `;
    }

    return html.replace(
        '</body>',
        `<script>
            // Inject document context
            window.documentUri = '${docUri}';
            window.documentDir = '${docDir}';

            // VS Code API for sync communication
            const vscode = acquireVsCodeApi();

            // Sync state
            let isUpdatingFromEditor = false;
            let syncEnabled = true;
            let activeListeners = [];

            // Clean up any existing sync listeners
            function cleanupSync() {
                console.log('üßπ Cleaning up previous sync listeners');
                activeListeners.forEach(cleanup => {
                    if (typeof cleanup === 'function') {
                        cleanup();
                    }
                });
                activeListeners = [];

                // Clear any existing timeouts
                if (window.aksaraSyncTimeout) {
                    clearTimeout(window.aksaraSyncTimeout);
                    window.aksaraSyncTimeout = null;
                }

                // Reset sync state
                isUpdatingFromEditor = false;
                syncEnabled = true;

                console.log('‚úÖ Sync cleanup completed');
            }

            // Hook into existing Aksara navigation functions
            function initializeVSCodeSync() {
                console.log('üîß Initializing VS Code sync...');

                // First, clean up any existing listeners
                cleanupSync();

                // Check if this is an Aksara document
                const hasAksara = document.body.innerHTML.includes('aksara') ||
                                document.querySelector('.document-section') ||
                                document.querySelector('.aksara-section');

                console.log('üîç Document analysis:', {
                    hasAksaraInHTML: document.body.innerHTML.includes('aksara'),
                    hasDocumentSections: !!document.querySelector('.document-section'),
                    hasAksaraSections: !!document.querySelector('.aksara-section'),
                    totalSections: document.querySelectorAll('.document-section').length,
                    isAksaraDoc: hasAksara
                });

                if (!hasAksara) {
                    console.log('‚ùå Not an Aksara document, skipping sync');
                    return;
                }

                // Store references to original navigation functions
                const originalNextSlide = window.nextSlide;
                const originalPreviousSlide = window.previousSlide;

                // Override navigation functions to notify VS Code
                if (typeof originalNextSlide === 'function') {
                    window.nextSlide = function() {
                        console.log('üì§ nextSlide() called - notifying editor');
                        originalNextSlide.call(this);
                        notifyEditorOfSlideChange();
                    };
                }

                if (typeof originalPreviousSlide === 'function') {
                    window.previousSlide = function() {
                        console.log('üì§ previousSlide() called - notifying editor');
                        originalPreviousSlide.call(this);
                        notifyEditorOfSlideChange();
                    };
                }

                // Handle scroll events for document mode - only when preview has focus
                let scrollTimeout;
                let lastScrollTime = 0;

                const scrollHandler = () => {
                    if (isUpdatingFromEditor) {
                        console.log('üîí Skipping scroll sync - updating from editor');
                        return;
                    }

                    // Only sync if preview has focus or was recently interacted with
                    if (!document.hasFocus()) {
                        console.log('üîí Skipping scroll sync - preview not focused');
                        return;
                    }

                    const now = Date.now();
                    if (now - lastScrollTime < 100) {
                        console.log('üîí Skipping scroll sync - debouncing');
                        return;
                    }

                    if (window.aksaraSyncTimeout) {
                        clearTimeout(window.aksaraSyncTimeout);
                    }
                    window.aksaraSyncTimeout = setTimeout(() => {
                        const section = getCurrentSection();
                        const line = estimateLineFromScroll();

                        console.log('üì§ Preview focused - scroll event notifying editor:', { section, line });

                        // Update slide counter for document mode
                        console.log('üîÑ Calling updateSlideCounterForDocument from scroll handler with section:', section);
                        updateSlideCounterForDocument(section);

                        vscode.postMessage({
                            type: 'preview-scroll',
                            section: section,
                            line: line
                        });

                        lastScrollTime = Date.now();
                    }, 150); // Reduced debounce time for more responsive counter updates
                };

                const messageHandler = (event) => {
                    const message = event.data;
                    console.log('üì® Message from editor:', message);

                    // Validate that the message is for the current document
                    if (message.sourceFile && window.documentUri) {
                        const currentFile = window.documentUri.split('/').pop();
                        const messageFile = message.sourceFile.split('/').pop();
                        if (currentFile !== messageFile) {
                            console.log('üîí Ignoring message for different file:', messageFile, 'vs current:', currentFile);
                            return;
                        }
                    }

                    if (message.type === 'cursor-moved' || message.type === 'scroll-changed') {
                        handleEditorSync(message.line, message.section);
                    }
                };

                // Register event listeners and track them for cleanup
                window.addEventListener('scroll', scrollHandler);
                window.addEventListener('message', messageHandler);

                // Track cleanup functions
                activeListeners.push(() => {
                    window.removeEventListener('scroll', scrollHandler);
                    window.removeEventListener('message', messageHandler);
                    if (window.aksaraSyncTimeout) {
                        clearTimeout(window.aksaraSyncTimeout);
                        window.aksaraSyncTimeout = null;
                    }
                });

                console.log('‚úÖ VS Code sync initialized with', activeListeners.length, 'tracked listeners');

                // Initialize slide counter for document mode
                const initialSection = getCurrentSection();
                updateSlideCounterForDocument(initialSection);
            }

            function notifyEditorOfSlideChange() {
                if (isUpdatingFromEditor) {
                    console.log('üîí Skipping slide notification - updating from editor');
                    return;
                }

                // Only notify if preview has focus
                if (!document.hasFocus()) {
                    console.log('üîí Skipping slide notification - preview not focused');
                    return;
                }

                const currentSection = getCurrentSlideIndex();
                console.log('üì§ Preview focused - notifying editor of slide change:', currentSection);

                vscode.postMessage({
                    type: 'slide-changed',
                    section: currentSection
                });
            }

            function getCurrentSlideIndex() {
                // Try to get current slide from global variable
                if (typeof window.currentSlide !== 'undefined') {
                    console.log('üìä Using window.currentSlide:', window.currentSlide);
                    return window.currentSlide;
                }

                // Fallback: find active slide
                const activeSlide = document.querySelector('.document-section.active, .slide.active');
                if (activeSlide) {
                    const slides = document.querySelectorAll('.document-section, .slide');
                    const index = Array.from(slides).indexOf(activeSlide);
                    console.log('üìä Found active slide at index:', index, 'of', slides.length, 'total slides');
                    return index;
                }

                console.log('üìä No active slide found, returning 0');
                return 0;
            }

            function getCurrentSection() {
                // For presentations, use the current slide index directly
                if (typeof window.currentSlide !== 'undefined') {
                    console.log('üìä Presentation mode - using currentSlide:', window.currentSlide);
                    return window.currentSlide;
                }

                // For documents: calculate based on scroll position and HR elements
                console.log('üìä Document mode - calculating section from scroll position');

                // Get all HR elements (from --- separators in markdown)
                const hrElements = Array.from(document.querySelectorAll('hr'));
                console.log('üìä Found', hrElements.length, 'HR elements in document');

                if (hrElements.length === 0) {
                    console.log('üìä No HR elements found, document has 1 section');
                    return 0;
                }

                // The sections are: [content before first HR] [content between HRs] [content after last HR]
                // So for N HR elements, we have N+1 sections (0 to N)
                const totalSections = hrElements.length + 1;
                const scrollTop = window.scrollY + window.innerHeight / 3; // Use 1/3 for better detection

                let currentSection = 0;

                // Check each HR element to see if we've scrolled past it
                for (let i = 0; i < hrElements.length; i++) {
                    const hr = hrElements[i];
                    const rect = hr.getBoundingClientRect();
                    const hrTop = rect.top + window.scrollY;

                    if (scrollTop > hrTop) {
                        currentSection = i + 1;
                    } else {
                        break;
                    }
                }

                // Clamp to valid range
                currentSection = Math.max(0, Math.min(currentSection, totalSections - 1));

                console.log('üìä Document section calculation:', {
                    scrollTop,
                    totalSections,
                    currentSection,
                    hrPositions: hrElements.map(hr => hr.getBoundingClientRect().top + window.scrollY)
                });

                return currentSection;
            }

            function estimateLineFromScroll() {
                const scrollPercent = window.scrollY / (document.documentElement.scrollHeight - window.innerHeight);
                const averageLineHeight = 24;
                const totalLines = Math.ceil(document.body.scrollHeight / averageLineHeight);
                return Math.floor(scrollPercent * totalLines);
            }

            function handleEditorSync(line, section) {
                console.log('üîÑ Handling editor sync:', { line, section });
                console.log('üîç Available globals:', {
                    currentSlide: typeof window.currentSlide,
                    showSlide: typeof window.showSlide,
                    nextSlide: typeof window.nextSlide,
                    previousSlide: typeof window.previousSlide
                });

                isUpdatingFromEditor = true;

                // Check if this is a presentation (has navigation functions or document sections)
                const hasNavFunctions = typeof window.nextSlide === 'function' || typeof window.previousSlide === 'function';
                const hasDocumentSections = document.querySelectorAll('.document-section').length > 0;
                const isPresentation = hasNavFunctions || hasDocumentSections;

                if (isPresentation) {
                    // Get total slides and clamp section to valid range
                    const totalSlides = document.querySelectorAll('.document-section').length;
                    const clampedSection = Math.max(0, Math.min(section, totalSlides - 1));

                    console.log('üéØ Presentation mode detected - navigating to slide:', clampedSection, 'of', totalSlides, '(requested:', section, ')');

                    // Navigate to the target slide using available methods
                    navigateToSlide(clampedSection);

                } else {
                    // For document mode: scroll to position
                    console.log('üìÑ Document mode - scrolling to section:', section);
                    scrollToSection(section);
                    // Update slide counter for document mode
                    updateSlideCounterForDocument(section);
                }

                setTimeout(() => {
                    isUpdatingFromEditor = false;
                    console.log('üîì Editor sync lock released');
                }, 500); // Increased timeout to prevent sync loops
            }

            function navigateToSlide(targetSlide) {
                console.log('üéØ Navigating to slide:', targetSlide);

                // Method 1: Use currentSlide + showSlide if available
                if (typeof window.currentSlide !== 'undefined' && typeof window.showSlide === 'function') {
                    console.log('üìû Method 1: Using currentSlide + showSlide');
                    window.currentSlide = targetSlide;
                    window.showSlide(targetSlide);
                    updateSlideCounter(targetSlide);
                    return;
                }

                // Method 2: Use nextSlide/previousSlide to navigate step by step
                if (typeof window.nextSlide === 'function' && typeof window.previousSlide === 'function') {
                    console.log('üìû Method 2: Using nextSlide/previousSlide navigation');
                    navigateWithStepFunctions(targetSlide);
                    return;
                }

                // Method 3: Manual slide visibility control
                console.log('üìû Method 3: Manual slide visibility update');
                updateSlideVisibility(targetSlide);
                updateSlideCounter(targetSlide);
            }

            function navigateWithStepFunctions(targetSlide) {
                // Get current slide index
                let currentSlide = getCurrentSlideFromDOM();
                console.log('üéØ Current slide:', currentSlide, 'Target slide:', targetSlide);

                if (currentSlide === targetSlide) {
                    console.log('‚úÖ Already on target slide');
                    return;
                }

                // Navigate step by step to target slide
                const steps = targetSlide - currentSlide;
                console.log('üéØ Need to move', steps, 'steps');

                function stepToTarget() {
                    const current = getCurrentSlideFromDOM();
                    if (current === targetSlide) {
                        console.log('‚úÖ Reached target slide:', targetSlide);
                        updateSlideCounter(targetSlide);
                        return;
                    }

                    if (current < targetSlide) {
                        console.log('‚û°Ô∏è Next slide (', current, '‚Üí', current + 1, ')');
                        window.nextSlide();
                    } else {
                        console.log('‚¨ÖÔ∏è Previous slide (', current, '‚Üí', current - 1, ')');
                        window.previousSlide();
                    }

                    // Continue stepping with small delay
                    setTimeout(stepToTarget, 50);
                }

                stepToTarget();
            }

            function getCurrentSlideFromDOM() {
                // Try to get from global variable first
                if (typeof window.currentSlide !== 'undefined') {
                    return window.currentSlide;
                }

                // Find active slide
                const activeSlide = document.querySelector('.document-section.active, .slide.active');
                if (activeSlide) {
                    const slides = document.querySelectorAll('.document-section, .slide');
                    return Array.from(slides).indexOf(activeSlide);
                }

                // Fallback: look for visible slide
                const slides = document.querySelectorAll('.document-section');
                for (let i = 0; i < slides.length; i++) {
                    const style = window.getComputedStyle(slides[i]);
                    if (style.display !== 'none' && style.visibility !== 'hidden') {
                        return i;
                    }
                }

                return 0;
            }

            function updateSlideCounter(slideIndex) {
                const counter = document.getElementById('current-slide');
                if (counter) {
                    counter.textContent = (slideIndex + 1).toString();
                    console.log('üìä Updated slide counter to:', slideIndex + 1);
                }
            }

            function updateSlideCounterForDocument(currentSection) {
                console.log('üìä *** updateSlideCounterForDocument CALLED ***');
                console.log('üìä Updating document slide counter for section:', currentSection);

                // Calculate total sections based on HR elements (same logic as getCurrentSection)
                const hrElements = document.querySelectorAll('hr');
                const totalSections = hrElements.length + 1; // N HR elements = N+1 sections

                console.log('üìä Found HR elements:', hrElements.length, 'Total sections:', totalSections);

                console.log('üìä Counter update:', {
                    currentSection: currentSection + 1,
                    totalSections,
                    hrCount: hrElements.length
                });

                // Find and update slide counter elements with better selectors
                const currentSlideSelectors = ['#current-slide', '.current-slide', '[data-current-slide]'];
                const totalSlideSelectors = ['#total-slides', '.total-slides', '[data-total-slides]'];

                let updatedCurrent = false;
                let updatedTotal = false;

                // Update current slide counter
                currentSlideSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(element => {
                        if (element) {
                            element.textContent = (currentSection + 1).toString();
                            console.log('üìä Updated current slide element:', selector, 'to:', currentSection + 1);
                            updatedCurrent = true;
                        }
                    });
                });

                // Update total slides counter
                totalSlideSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(element => {
                        if (element) {
                            element.textContent = totalSections.toString();
                            console.log('üìä Updated total slides element:', selector, 'to:', totalSections);
                            updatedTotal = true;
                        }
                    });
                });

                // Fallback: look for any element containing slide numbers
                if (!updatedCurrent || !updatedTotal) {
                    console.log('üìä Primary selectors failed, searching all elements for counter patterns');
                    const allElements = document.querySelectorAll('*');
                    let foundElements = 0;

                    allElements.forEach(element => {
                        const text = element.textContent || '';
                        // Look for patterns like "1 of 5", "Page 1/5", etc.
                        if (text.match(/\b\d+\s*(of|\/)\s*\d+\b/)) {
                            foundElements++;
                            console.log('üìä Found counter element:', element.tagName, element.className, 'text:', text);
                            const newText = text.replace(/\b\d+(\s*(?:of|\/)\s*)\d+\b/, (currentSection + 1) + '$1' + totalSections);
                            if (newText !== text) {
                                element.textContent = newText;
                                console.log('üìä Updated slide counter via pattern match:', text, '->', newText);
                                updatedCurrent = true;
                                updatedTotal = true;
                            }
                        }
                    });

                    console.log('üìä Found', foundElements, 'potential counter elements');
                }

                // Final fallback: look for common counter text patterns
                if (!updatedCurrent || !updatedTotal) {
                    console.log('üìä Pattern matching failed, trying innerHTML search');
                    const bodyText = document.body.innerHTML;
                    if (bodyText.includes(' of ') || bodyText.includes('/')) {
                        console.log('üìä Found potential counter patterns in body HTML');
                        // Try to find and replace in innerHTML (more aggressive)
                        const newBodyHTML = bodyText.replace(/(\b\d+)(\s*(?:of|\/)\s*)(\d+\b)/g,
                            (match, p1, p2, p3) => (currentSection + 1) + p2 + totalSections);
                        if (newBodyHTML !== bodyText) {
                            document.body.innerHTML = newBodyHTML;
                            console.log('üìä Updated counters via innerHTML replacement');
                            updatedCurrent = true;
                            updatedTotal = true;
                        }
                    }
                }

                // Force a repaint to make changes visible immediately
                document.body.style.transform = 'translateZ(0)';
                setTimeout(() => {
                    document.body.style.transform = '';
                }, 1);

                // Also update window.currentSlide if it exists (for compatibility)
                if (typeof window.currentSlide !== 'undefined') {
                    window.currentSlide = currentSection;
                    console.log('üìä Updated window.currentSlide to:', currentSection);
                }
            }

            function updateSlideVisibility(targetSlide) {
                const slides = document.querySelectorAll('.document-section');
                console.log('üéûÔ∏è Manually updating slide visibility - target:', targetSlide, 'total slides:', slides.length);

                slides.forEach((slide, index) => {
                    slide.style.display = index === targetSlide ? 'block' : 'none';
                    if (index === targetSlide) {
                        slide.classList.add('active');
                    } else {
                        slide.classList.remove('active');
                    }
                });
            }

            function scrollToSection(sectionIndex) {
                console.log('üìÑ Document scrollToSection called for index:', sectionIndex);

                // Get HR elements (same logic as getCurrentSection)
                const hrElements = Array.from(document.querySelectorAll('hr'));
                const totalSections = hrElements.length + 1;

                console.log('üìÑ Scroll to section:', {
                    sectionIndex,
                    totalSections,
                    hrCount: hrElements.length
                });

                // Clamp section index to valid range
                const clampedIndex = Math.max(0, Math.min(sectionIndex, totalSections - 1));

                if (clampedIndex === 0) {
                    // Section 0: scroll to top of document
                    console.log('üìÑ Scrolling to section 0 (top of document)');
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                } else if (clampedIndex <= hrElements.length) {
                    // Section N: scroll to HR element N-1
                    const targetHr = hrElements[clampedIndex - 1];
                    if (targetHr) {
                        console.log('üìÑ Scrolling to HR element', clampedIndex - 1, 'for section', clampedIndex);
                        targetHr.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    } else {
                        console.log('üìÑ HR element not found, using fallback scroll');
                        const percentage = clampedIndex / totalSections;
                        const scrollY = percentage * (document.documentElement.scrollHeight - window.innerHeight);
                        window.scrollTo({ top: scrollY, behavior: 'smooth' });
                    }
                } else {
                    // Fallback for out-of-range sections
                    console.log('üìÑ Section out of range, scrolling to end');
                    window.scrollTo({
                        top: document.documentElement.scrollHeight,
                        behavior: 'smooth'
                    });
                }
            }

            // Initialize with retry mechanism for Aksara functions
            function tryInitializeSync() {
                console.log('‚è∞ Attempting sync initialization...');

                // Check if document has Aksara content
                const hasAksaraContent = document.body.innerHTML.includes('aksara') ||
                                       document.querySelector('.document-section') ||
                                       document.querySelector('.aksara-section') ||
                                       document.querySelectorAll('hr').length > 0 ||
                                       document.querySelectorAll('h1').length > 0;

                // Check if Aksara presentation functions are available (for presentations)
                const hasAksaraFunctions = typeof window.nextSlide === 'function' ||
                                          typeof window.currentSlide !== 'undefined' ||
                                          document.querySelectorAll('.document-section').length > 0;

                if (hasAksaraContent) {
                    console.log('‚úÖ Aksara content detected, initializing sync');
                    initializeVSCodeSync();
                } else if (hasAksaraFunctions) {
                    console.log('‚è≥ Aksara functions detected but no content yet, retrying in 500ms...');
                    setTimeout(tryInitializeSync, 500);
                } else {
                    console.log('‚ùå No Aksara content detected, skipping sync initialization');
                }
            }

            // Clean up any global state from previous loads
            if (window.aksaraInitialized) {
                console.log('üîÑ Previous Aksara instance detected, cleaning up...');
                cleanupSync();
            }
            window.aksaraInitialized = true;

            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    setTimeout(tryInitializeSync, 100); // Small delay after DOM ready
                });
            } else {
                setTimeout(tryInitializeSync, 100); // Small delay if already loaded
            }
        </script>
        </body>`
    );
}

/**
 * Get fallback template if file reading fails
 */
function getFallbackTemplate(): string {
    return `<!--
aksara:true
type: document
style: ./style.css
size: 210mmx297mm
meta:
    title: Dokumen Bisnis
    subtitle: Document Professional
header: | PT. Perusahaan | Dokumen | \${new Date().toLocaleDateString('id-ID')} |
footer: Halaman [page] dari [total] - Dibuat dengan Aksara Writer
-->

# Judul Dokumen

## Pendahuluan

Ini adalah dokumen bisnis yang dibuat dengan **Aksara Writer**.

### Fitur Utama

- ‚úÖ Konversi ke PDF, HTML, dan PPTX
- üáÆüá© Dukungan Bahasa Indonesia
- üìÑ Template bisnis profesional
- üé® Tema yang dapat disesuaikan

## Kesimpulan

Aksara Writer memudahkan pembuatan dokumen profesional untuk bisnis Indonesia.

---
*Dibuat dengan Aksara Writer*
`;
}

/**
 * Webview provider for preview panel
 */
class AksaraPreviewProvider implements vscode.WebviewViewProvider {
    constructor(private readonly extensionUri: vscode.Uri) {}

    resolveWebviewView(webviewView: vscode.WebviewView): void {
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this.extensionUri]
        };

        webviewView.webview.html = this.getWelcomeHtml();
    }

    private getWelcomeHtml(): string {
        return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Aksara Writer</title>
            <style>
                body {
                    font-family: 'Segoe UI', sans-serif;
                    padding: 20px;
                    text-align: center;
                    color: #333;
                }
                .logo { font-size: 2em; margin-bottom: 1em; }
                .welcome { margin-bottom: 2em; }
                .actions button {
                    background: #007ACC;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    margin: 5px;
                    border-radius: 4px;
                    cursor: pointer;
                }
            </style>
        </head>
        <body>
            <div class="logo">üìù Aksara Writer</div>
            <div class="welcome">
                <p>Selamat datang di <strong>Aksara Writer</strong>!</p>
                <p>Buat dokumen profesional dengan mudah.</p>
            </div>
            <div class="actions">
                <p>Buka file markdown untuk melihat preview di sini.</p>
            </div>
        </body>
        </html>
        `;
    }
}

export function deactivate() {}